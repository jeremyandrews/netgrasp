#!/usr/bin/env python2

import argparse
import ConfigParser
import sys
import os
import pwd
import signal
import errno
import datetime

class NetgraspShared:
    BROADCAST = 'ff:ff:ff:ff:ff:ff'

    DEFAULT_PIDFILE   = "netgrasp.pid"
    DEFAULT_DBLOCK    = "/tmp/.database_lock"
    DEFAULT_CONFIG    = ['/etc/netgrasp.cfg', '/usr/local/etc/netgrasp.cfg', '~/.netgrasp.cfg', './netgrasp.cnf']

    class Config:
        def __init__(self, parser, config = False):
            self.parser = parser
            if config:
                self.found = self.parser.read(config)
            else:
                self.found = self.parser.read(ngs.DEFAULT_CONFIG)

        def _GetValue(self, section, option, value, default, required, secret):
            if not value and default:
                value = default
            if required and not value:
                sys.exit("""Required [%s] '%s' not defined in configuration file, exiting.""" % (section, option))
            if self.verbose > 1:
                if value:
                    if secret:
                        print """Configuration %s set from [%s]""" % (option, section)
                    else:
                        print """Configuration %s set to '%s' from [%s]""" % (option, value, section)
                else:
                    if default:
                        if secret:
                            print """Configuration %s set to default from [%s]""" % (option, section)
                        else:
                            if self.parser.has_section(section):
                                print """Configuration %s set to default of %s from [%s]""" % (option, value, section)
                            else:
                                print """Configuration %s set to default of %s, [%s] does not exist""" % (option, value, section)
            return value

        def GetText(self, section, option, default = None, required = True, secret = False):
            if (self.parser.has_section(section) and self.parser.has_option(section, option)):
                value = self.parser.get(section, option)
            else:
                value = None
            return self._GetValue(section, option, value, default, required, secret)

        def GetInt(self, section, option, default = None, required = True, secret = False):
            if (self.parser.has_section(section) and self.parser.has_option(section, option)):
                value = self.parser.getint(section, option)
            else:
                value = None
            return self._GetValue(section, option, value, default, required, secret)

        def GetBoolean(self, section, option, default = None, required = True, secret = False):
            if (self.parser.has_section(section) and self.parser.has_option(section, option)):
                value = self.parser.getboolean(section, option)
            else:
                value = None
            return self._GetValue(section, option, value, default, required, secret)

    class Database:
        def __init__(self):
            try:
                import sqlite3
            except Exception as e:
                sys.exit("Failed to import sqlite3, try: 'pip install sqlite3', exiting.")

            self.connection = sqlite3.connect(ngs.database_filename, detect_types=sqlite3.PARSE_DECLTYPES)

    # Determine who we are, for pretty logging.
    def whoami(self):
        whoami = pwd.getpwuid(os.getuid())
        return whoami[0]

class ExclusiveFileLock:
    def __init__(self, lockfile):
        self.lockfile = lockfile
        # Create the lockfile if it doesn't already exist.
        self.handle = open(lockfile, 'w')

    # Acquire exclusive, blocking lock.
    def acquire(self):
        fcntl.flock(self.handle, fcntl.LOCK_EX)

    # Release exclusive, blocking lock.
    def release(self):
        fcntl.flock(self.handle, fcntl.LOCK_UN)

    def __del__(self):
        self.handle.close()

class SelectQueryBuilder():
    def __init__(self, table):
        self.table = table
        self.select = []
        self.where = []
        self.where_args = []
        self.group = []
        self.order = []

    def db_select(self, key, table = None):
        if not table:
            table = self.table
        self.select.append(table + "." + key)

    def db_where(self, key, value, table = None):
        if not table:
            table = self.table
        self.where.append(table + "." + key)
        self.where_args.append(value)

    def db_group(self, key, table = None):
        if not table:
            table = self.table
        self.group.append(key)

    def db_order(self, value, table = None):
        if not table:
            table = self.table
        self.order.append(table + "." + value)

    def db_query(self):
        query_string = "SELECT " + ", ".join(self.select) + " FROM " + self.table + " WHERE " + " AND ".join(self.where)
        if len(self.group):
            query_string += " GROUP BY " + ", ".join(self.group)
        if len(self.order):
            query_string += " ORDER BY " + ", ".join(self.order)
        if ngs.config_instance.verbose > 1:
            print 'Select query: ', query_string
        return query_string

    def db_args(self):
        if ngs.config_instance.verbose > 1:
            print 'Select args: ', self.where_args
        return self.where_args

# Determine if pid in pidfile is a running process.
def is_running(pidfile):
    running = False
    if os.path.isfile(pidfile):
        f = open(pidfile)
        pid = int(f.readline())
        f.close()
        if pid > 0:
            if ngs.config_instance.verbose > 1:
                print """Found pidfile %s, contained pid %d""" % (pidfile, pid)
            try:
                os.kill(pid, 0)
            except OSError as e:
                if e.errno == errno.EPERM:
                    running = pid
            else:
                running = pid
    return running

def pretty_date(time):
    if not time:
        return "never"
    now = datetime.datetime.now()
    diff = now - time
    second_diff = diff.seconds
    day_diff = diff.days

    if day_diff < 0:
        return ''

    if day_diff == 0:
        if second_diff < 10:
            return "just now"
        if second_diff < 60:
            return str(second_diff) + " seconds ago"
        if second_diff < 120:
            return "a minute ago"
        if second_diff < 3600:
            return str(second_diff / 60) + " minutes ago"
        if second_diff < 7200:
            return "an hour ago"
        if second_diff < 86400:
            return str(second_diff / 3600) + " hours ago"
    if day_diff == 1:
        return "yesterday"
    if day_diff < 7:
        return str(day_diff) + " days ago"
    if day_diff < 31:
        return str(day_diff / 7) + " weeks ago"
    if day_diff < 365:
        return str(day_diff / 30) + " months ago"
    return str(day_diff / 365) + " years ago"

# Provides a human-friendly name for a mac-ip pair.
def name_ip(mac, ip):
    if (mac == ngs.BROADCAST):
        ngs.database_instance.cursor.execute("SELECT h.mac, h.ip, h.customname, h.hostname, v.customname, v.vendor FROM host h LEFT JOIN vendor v ON h.mac = v.mac WHERE h.ip=?", (ip,))
    else:
        ngs.database_instance.cursor.execute("SELECT h.mac, h.ip, h.customname, h.hostname, v.customname, v.vendor FROM host h LEFT JOIN vendor v ON h.mac = v.mac WHERE h.ip=? AND h.mac=?", (ip, mac))
    detail = ngs.database_instance.cursor.fetchone()
    if not detail:
        return detail
    if detail[2]:
        return detail[2]
    elif detail[3] and (detail[3] != 'unknown'):
        return detail[3]
    elif detail[4]:
        return detail[4]
    elif detail[5]:
        return """Unidentified device by %s""" % (detail[5])
    else:
        return detail[0]

# Truncate strings with they're too long.
def truncate_string(string, maxlength, suffix = "..."):
    if len(string) <= maxlength:
        return string
    return """%s%s""" % (string[:(maxlength - len(suffix))], suffix)

def start(args):
    if ngs.is_running:
        sys.exit("""Netgrasp is already running with pid %d.""" % ngs.is_running)
    if args.verbose:
        print "Starting netgrasp..."

def stop(args):
    if not ngs.is_running:
        sys.exit("Netgrasp is not running.")
    if args.verbose:
        print "Stopping netgrasp..."
    try:
        os.kill(ngs.is_running, signal.SIGTERM)
    except OSError as e:
        if e.errno == errno.EPERM:
            print """Failed (perhaps try with sudo): %s""" % e
        else:
            print """Failed: %s""" % e

def restart(args):
    stop(args)
    start(args)

def status(args):
    if ngs.is_running:
        print """Netgrasp is running with pid %d""" % (ngs.is_running)
    else:
        print "Netgrasp is not running."

def list(args):
    if not ngs.is_running:
        sys.exit("Netgrasp is not running.")

    ngs.database_filename = ngs.config_instance.GetText('Database', 'filename')

    try:
        ngs.database_instance = ngs.Database()
    except Exception as e:
        print e
        sys.exit("""Failed to open or create database file %s (as user %s), exiting.""" % (ngs.database_filename, ngs.whoami()))

    if args.verbose:
        print """Opened %s as user %s""" % (ngs.database_filename, ngs.whoami())

    ngs.database_instance.cursor = ngs.database_instance.connection.cursor()
    #ngs.database_lock = ExclusiveFileLock(ngs.config_instance.GetText('Database', 'lockfile', ngs.DEFAULT_DBLOCK, False))

    if args.type == 'device':
        # List devices.
        query = SelectQueryBuilder("seen")
        query.db_select("mac")
        query.db_select("ip")
        query.db_select("lastSeen")

        if args.all:
            description = "All devices"
        else:
            description = "Active devices"
            query.db_where("active = ?", 1)

        if (not args.all or args.all == 1):
            query.db_group("mac")
            query.db_group("ip")

        query.db_order("lastSeen DESC")

        rowFormat = "{:>16}{:>34}{:>22}"
        header = ["IP", "Name", "Last seen"]

    elif args.type == 'event':
        # List events.
        query = SelectQueryBuilder('event')
        query.db_select("mac")
        query.db_select("ip")
        query.db_select("timestamp")
        query.db_select("event")

        if args.all:
            description = "All alerts"
        else:
            description = 'Recent alerts'
            ngs.active_timeout = ngs.config_instance.GetInt('Listen', 'active_timeout', 60 * 60 * 2, False)
            recent = datetime.datetime.now() - datetime.timedelta(seconds=ngs.active_timeout)
            query.db_where("timestamp >= ?", recent)

        if (not args.all or args.all == 1):
            query.db_group("mac")
            query.db_group("ip")
            query.db_group("event")

        query.db_order("timestamp DESC")

        rowFormat = "{:>16}{:>24}{:>21}{:>18}"
        header = ["IP", "Name", "Event", "Last seen"]

    if args.mac:
        query.db_where("mac LIKE ?", "%"+args.mac+"%")
        if not args.mac == ngs.BROADCAST:
            query.db_where("mac != ?", ngs.BROADCAST)
    else:
        query.db_where("mac != ?", ngs.BROADCAST)

    if args.ip:
        query.db_where("ip LIKE ?", "%"+args.ip+"%")

    ngs.database_instance.cursor.execute(query.db_query(), query.db_args())
    rows = ngs.database_instance.cursor.fetchall()
    if rows:
        print """ %s:""" % description
        print rowFormat.format(*header)
    for row in rows:
        if args.type == 'device':
            print rowFormat.format(truncate_string(row[1], 15), truncate_string(name_ip(row[0], row[1]), 32), truncate_string(pretty_date(row[2]), 20))
        else:
            print rowFormat.format(truncate_string(row[1], 15), truncate_string(name_ip(row[0], row[1]), 22), truncate_string(row[3], 19), truncate_string(pretty_date(row[2]), 16))

def identify(args):
    print 'identify', args

if __name__ == '__main__':
    parser = argparse.ArgumentParser(
            prog='netgraspctl',
            description='A passive network observation tool')
    # --verbose -v, verbose
    parser.add_argument('--verbose', '-v', action='count', help='verbose output')
    # --config -c, configuration file
    parser.add_argument('--config', '-c', help='specify custom path for configuration file')

    subparsers = parser.add_subparsers()

    # start
    parser_start = subparsers.add_parser('start', help='start netgrasp')
    parser_start.set_defaults(func=start)

    # stop
    parser_stop = subparsers.add_parser('stop', help='stop netgrasp')
    parser_stop.set_defaults(func=stop)

    # restart
    parser_restart = subparsers.add_parser('restart', help='restart netgrasp')
    parser_restart.set_defaults(func=restart)

    # status
    parser_status = subparsers.add_parser('status', help='netgrasp status')
    parser_status.set_defaults(func=status)

    # list     (li, -l) ,v,e(events),d(devices),i(ip),m(mac), t(type: device,event)
    parser_list = subparsers.add_parser('list', help='list devices')
    parser_list.add_argument('--type', '-t', choices=['device', 'event'], default='device', help='type of object to list')
    parser_list.add_argument('--all', '-a', action='count', help='list all devices/events')
    parser_list.add_argument('--mac', '-m', help='filter by mac address (ex. -m ff:ff)')
    parser_list.add_argument('--ip', '-i', help='filter by ip address (ex. -i 127.0)')
    parser_list.add_argument('--vendor', '-v', help='filter by vendor (ex. -v apple)')
    parser_list.set_defaults(func=list)

    # identify (id, -i) ,v,i(ip),m(mac)
    parser_identify = subparsers.add_parser('identify', help='identify devices')
    parser_identify.add_argument('--mac', '-m', help='filter by mac address (ex. -m ff:ff:ff:ff:ff:ff)')
    parser_identify.add_argument('--ip', '-i', help='filter by ip address (ex. -i 127.0.0.1)')
    parser_identify.add_argument('--custom', '-c', help='set custom name (ex. -c "my iPhone")')
    parser_identify.set_defaults(func=identify)

    args = parser.parse_args()

    # @TODO import shared class from a common module.
    ngs = NetgraspShared()

    # Find/load configuration files(s).
    if args.config:
        configs = args.config
    else:
        configs = ngs.DEFAULT_CONFIG
    ngs.config_instance = ngs.Config(ConfigParser.ConfigParser(), configs)
    ngs.config_instance.verbose = args.verbose
    if not ngs.config_instance.found:
        sys.exit("""Configuration file not found at the following paths: %s, exiting.""" % (configs))
    if ngs.config_instance.verbose > 1:
        print """Loaded configuration file(s): %s""" % (ngs.config_instance.found)
    if ngs.config_instance.verbose > 2:
        print args

    # Find/load pidfile.
    ngs.pidfile = ngs.config_instance.GetText('Logging', 'pidfile', ngs.DEFAULT_PIDFILE, False)
    ngs.is_running = is_running(ngs.pidfile)

    args.func(args)

#!/usr/bin/env python
import os
import sys
import signal
import multiprocessing
import ConfigParser
import io
import logging
import pwd
import struct
import socket
import datetime
from email.utils import parseaddr

BROADCAST = 'ff:ff:ff:ff:ff:ff'

EVENT_REQUESTED_FIRST   = 'first_requested'
EVENT_REQUESTED         = 'requested'
EVENT_SEEN_FIRST        = 'first_seen'
EVENT_SEEN_FIRST_RECENT = 'first_seen_recently'
EVENT_SEEN              = 'seen'
EVENT_STALE             = 'stale'

PROCESSED_ALERT  = 1
PROCESSED_DIGEST = 3

def wiretap(child_conn):
    import sys
    name = multiprocessing.current_process().name
    assert os.getuid() == 0, 'Unable to initiate pcap, must be run as root.'
    logger.info('wiretap process running as user %s',  whoami())
    try:
        import dpkt
    except:
        logger.critical("failed to import dpkt, try: 'pip install dpkt', exiting")
        sys.exit("ERROR: Failed to import dpkt, try: 'pip install dpkt'")
    try:
        import pcap
    except:
        logger.critical("failed to import pcap, try: 'pip install pypcap', exiting")
        sys.exit("ERROR: Failed to import pcap, try: 'pip install pypcap'")

    devices = pcap.findalldevs()
    logger.debug('identified devices: %s', devices)
    if len(devices) <= 0:
      logger.critical('no available devices (are you in a jail?), exiting')
      sys.exit("ERROR: No available devices, try running tcpdump manually to debug.")
    default_interface = devices[0]

    if config.has_section('Listen'):
      if config.has_option('Listen', 'interface'):
        default_interface = config.get('Listen', 'interface');
        if default_interface not in devices:
          logger.critical('invalid interface %s configured, exiting.', default_interface)
          sys.exit("ERROR: Invalid interface configured.")
        logger.debug('Listen: setting interface to %s', default_interface)
      else:
        logger.info('no interface configured, attempt to use first available.')
    else:
      logger.info('no interface configured, attempt to use first available.')

    interface = default_interface
    logger.info('configured to listen on interface %s', interface)
    local_net, local_mask = pcap.lookupnet(interface)

    pc = pcap.pcap(name=interface, snaplen=256, promisc=True, timeout_ms = 100, immediate=True)

    # drop all root privileges, we no longer need them
    os.setgroups([])
    os.setgid(gid)
    os.setuid(uid)

    assert (os.getuid() != 0) and (os.getgid() != 0), 'Failed to drop root privileges, aborting.'
    logger.info('wiretap process running as user %s',  whoami())

    pc.setfilter('arp')

    while True:
        if child_conn.poll():
            message = child_conn.recv()
            if (message == 'ABORT'):
                logger.critical('we have received ABORT message, exiting')
                sys.exit(0)
        pc.loop(1, received_arp, child_conn)

def received_arp(hdr, data, child_conn):
    import dpkt
    logger.debug('arp packet sniffed')
    child_conn.send(dpkt.ethernet.Ethernet(data))
    exit

def whoami():
    whoami = pwd.getpwuid(os.getuid())
    return whoami[0]

def create_database():
    db_cursor.execute("""
      CREATE TABLE IF NOT EXISTS seen(
        sid INTEGER PRIMARY KEY,
        mac TEXT,
        ip TEXT,
        interface TEXT,
        network TEXT,
        firstSeen TIMESTAMP,
        firstSeenRecent TIMESTAMP,
        lastSeen TIMESTAMP,
        lastRequested TIMESTAMP,
        active NUMERIC,
        self NUMERIC
      )
    """)
    db_cursor.execute("""
      CREATE TABLE IF NOT EXISTS arplog(
        aid INTEGER PRIMARY KEY,
        src_mac TEXT,
        src_ip TEXT,
        dst_mac TEXT,
        dst_ip TEXT,
        interface TEXT,
        network TEXT,
        timestamp TIMESTAMP
      )
    """)
    db_cursor.execute("""
      CREATE TABLE IF NOT EXISTS event(
        eid INTEGER PRIMARY KEY,
        mac TEXT,
        ip TEXT,
        interface TEXT,
        network TEXT,
        timestamp TIMESTAMP,
        processed NUMERIC,
        event TEXT
      )
    """)
    db_cursor.execute("""
      CREATE TABLE IF NOT EXISTS info(
        iid INTEGER PRIMARY KEY,
        mac TEXT,
        vendor TEXT,
        hostname TEXT,
        customname TEXT
      )
    """)
    db_conn.commit()

def clean_shutdown(signal, frame):
    # Log the reason we have exited
    logger.critical("SIGINT received, exiting")
    sys.exit(0)

def ip_is_mine(ip):
    return (ip == socket.gethostbyname(socket.gethostname()))

def ip_seen(src_ip, src_mac, dst_ip, dst_mac):
    now = datetime.datetime.now()

    if arplog:
      logger.debug("INSERT INTO arplog (src_mac, src_ip, dst_mac, dst_ip, timestamp) VALUES('%s', '%s', '%s', '%s', '%s')", src_mac, src_ip, dst_mac, dst_ip, now)
      db_cursor.execute('INSERT INTO arplog (src_mac, src_ip, dst_mac, dst_ip, timestamp) VALUES(?, ?, ?, ?, ?)', (src_mac, src_ip, dst_mac, dst_ip, now))

    # @TODO research and see if we should be treating this another way
    if (src_ip == '0.0.0.0'):
        logger.info('Ignoring IP source of 0.0.0.0');
        return False

    exists = False
    logger.debug("SELECT active, lastSeen FROM seen WHERE ip = '%s' AND mac = '%s'", src_ip, src_mac)
    db_cursor.execute('SELECT active, lastSeen FROM seen WHERE ip=? AND mac=?', (src_ip, src_mac))
    rows = db_cursor.fetchall()
    if len(rows):
        exists = True
        active = rows[0][0]
        lastSeen = rows[0][1]
    else:
        if (src_mac != BROADCAST):
            logger.debug("SELECT active, lastSeen FROM seen WHERE ip = '%s' AND mac = '%s'", src_ip, BROADCAST)
            db_cursor.execute('SELECT active, lastSeen FROM seen WHERE ip=? AND mac=?', (src_ip, BROADCAST))
            rows = db_cursor.fetchall()
            if len(rows):
                exists = True
                active = rows[0][0]
                lastSeen = rows[0][1]

    if exists:
        # Update:
        if active or not lastSeen:
            if lastSeen:
                log_event(src_ip, src_mac, EVENT_SEEN)
                logger.debug('%s (%s) is active', src_ip, src_mac)
                logger.debug("UPDATE seen set mac='%s', lastSeen='%s', active=1 WHERE ip='%s'", src_mac, now, src_ip)
                db_cursor.execute('UPDATE seen set mac=?, lastSeen=?, active=? WHERE ip=?', (src_mac, now, 1, src_ip))
            else:
                log_event(src_ip, src_mac, EVENT_SEEN_FIRST)
                logger.info('%s (%s) is active, first time seeing', src_ip, src_mac)
                logger.debug("UPDATE seen set mac='%s', firstSeen='%s', firstSeenRecent='%s', lastSeen='%s', active=1 WHERE ip='%s'", src_mac, now, now, now, src_ip)
                db_cursor.execute('UPDATE seen set mac=?, firstSeen=?, firstSeenRecent=?, lastSeen=?, active=? WHERE ip=?', (src_mac, now, now, now, 1, src_ip))
        else:
            log_event(src_ip, src_mac, EVENT_SEEN_FIRST_RECENT)
            timeSince = datetime.datetime.now() - lastSeen
            # First time we've seen IP since it was stale.
            logger.debug("UPDATE seen set mac='%s', firstSeenRecent='%s', lastSeen='%s', active=1 WHERE ip='%s'", src_mac, now, now, src_ip)
            db_cursor.execute('UPDATE seen set mac=?, firstSeenRecent=?, lastSeen=?, active=? WHERE ip=?', (src_mac, now, now, 1, src_ip))
            logger.info('%s (%s) is active again (after %s)', src_ip, src_mac, timeSince)
        db_conn.commit()
    else:
        # First time we've seen this IP.
        log_event(src_ip, src_mac, EVENT_SEEN_FIRST)
        logger.debug("INSERT INTO seen (mac, ip, firstSeen, firstSeenRecent, lastSeen, active, self) VALUES('%s', '%s', '%s', '%s', '%s', %d, %d)", src_mac, src_ip, now, now, now, 1, ip_is_mine(src_ip))
        db_cursor.execute('INSERT INTO seen (mac, ip, firstSeen, firstSeenRecent, lastSeen, active, self) VALUES(?, ?, ?, ?, ?, ?, ?)', (src_mac, src_ip, now, now, now, 1, ip_is_mine(src_ip)))
        logger.info('%s (%s) is active, first time seeing', src_ip, src_mac)
        db_conn.commit()

def ip_request(ip, mac):
    now = datetime.datetime.now()
    exists = False

    logger.debug("SELECT active FROM seen WHERE ip = '%s' AND mac = '%s'", ip, mac)
    db_cursor.execute('SELECT active FROM seen WHERE ip=? AND mac=?', (ip, mac))
    rows = db_cursor.fetchall()
    if len(rows):
        exists = True
    else:
        if (mac == BROADCAST):
            # Maybe we already have this ARP address
            logger.debug("SELECT mac FROM seen WHERE ip = '%s'", ip)
            db_cursor.execute('SELECT mac FROM seen WHERE ip=?', (ip,))
            rows = db_cursor.fetchall()
            if len(rows):
                exists = True
                mac = rows[0][0]

    if exists:
        # Update:
        log_event(ip, mac, EVENT_REQUESTED)
        logger.debug("UPDATE seen set lastRequested='%s' WHERE ip='%s' AND mac='%s'", now, ip, mac)
        db_cursor.execute('UPDATE seen set lastRequested=? WHERE ip=? AND mac=?', (now, ip, mac))
        logger.debug('%s (%s) requested', ip, mac)
        db_conn.commit()
    else:
        # First time we've seen a request for this IP.
        log_event(ip, mac, EVENT_REQUESTED_FIRST)
        logger.debug("INSERT INTO seen (mac, ip, lastRequested, active, self) VALUES('%s', '%s', '%s', 0, %d)", mac, ip, now, ip_is_mine(ip))
        db_cursor.execute("INSERT INTO seen (mac, ip, lastRequested, active, self) VALUES(?, ?, ?, 0, ?)", (mac, ip, now, ip_is_mine(ip)))
        logger.info('%s (%s) requested, first time seeing', ip, mac)
        db_conn.commit()

def log_event(ip, mac, event):
    now = datetime.datetime.now()
    logger.debug("INSERT INTO event (mac, ip, timestamp, processed, event) VALUES('%s', '%s', '%s', '%s', '%s')", mac, ip, now, 0, event)
    db_cursor.execute('INSERT INTO event (mac, ip, timestamp, processed, event) VALUES(?, ?, ?, ?, ?)', (mac, ip, now, 0, event))

# Mark IP/MAC pairs as no longer active if we've not seen ARP activity for >active_timeout seconds
def detect_stale_ips():
    stale = datetime.datetime.now() - datetime.timedelta(seconds=active_timeout)
    logger.debug("SELECT mac, ip, firstSeenRecent, lastSeen FROM seen WHERE active = 1 AND lastSeen < '%s'", stale)
    db_cursor.execute('SELECT mac, ip, firstSeenRecent, lastSeen FROM seen WHERE active = 1 AND lastSeen < ?', (stale,))
    rows = db_cursor.fetchall()
    commit = 0
    for row in rows:
        if (row[2] and row[3]):
            timeActive = row[3] - row[2]
        else:
            timeActive = 'unknown'
        log_event(row[1], row[0], EVENT_STALE)
        logger.info("%s [%s] is no longer active (was active for %s)", row[1], row[0], timeActive)
        logger.debug("UPDATE seen SET active = 0 WHERE mac = '%s' AND ip = '%s'", row[0], row[1])
        db_cursor.execute('UPDATE seen SET active = 0 WHERE mac=? AND ip=?', (row[0], row[1]))
        commit = 1
    if commit:
        db_conn.commit()

def send_email_alerts():
    import smtplib
    day = datetime.datetime.now() - datetime.timedelta(days=1)
    logger.debug('SELECT eid, mac, ip, timestamp, event FROM event WHERE NOT (processed & %d)', PROCESSED_ALERT);
    # @TODO, use variable: 1 == PROCESSED_ALERT
    db_cursor.execute('SELECT eid, mac, ip, timestamp, event, processed FROM event WHERE NOT (processed & 1)');
    rows = db_cursor.fetchall()
    commit = 0
    for row in rows:
        commit = 1
        logger.debug('processing event %d for %s [%s] at %s', row[0], row[2], row[1], row[3])
        db_cursor.execute('UPDATE event SET processed = ? WHERE eid = ?', (row[5] + 1, row[0]))
        # only send emails for configured events
        if row[4] in alerts:
            logger.info('event %s [%d] in %s, generating notification email', row[4], row[0], alerts)
            # get more information about this entry ...
            db_cursor.execute('SELECT s.firstSeen, s.firstSeenRecent, s.lastSeen, s.lastRequested, s.active, s.self, i.vendor, i.hostname, i.customname FROM seen s LEFT JOIN info i ON s.mac = i.mac WHERE s.mac=?', (row[1],))
            info = db_cursor.fetchone()
            subject = """Netgrasp alert: %s""" % (row[4])
            body = """IP %s [%s]\n  Vendor: %s\n  Hostname: %s\n  Custom name: %s\n  First seen: %s\n  First seen recently: %s\n  Last seen: %s\n  Last requested: %s\n  Currently active: %d\n  Self: %d\n""" % (row[2], row[1], info[6], info[7], info[8], info[0], info[1], info[2], info[3], info[4], info[5])
            db_cursor.execute('SELECT DISTINCT(dst_ip), dst_mac FROM arplog WHERE src_mac=? AND timestamp>=?', (row[1], day))
            results = db_cursor.fetchall()
            if results:
                body += """\nIn the last day, this device talked to:"""
            for peer in results:
                body += """\n - %s""" % (peer[0])
            message = """From: %s\nTo: %s\nSubject: %s\n\n%s""" % (email_from, ", ".join(email_to), subject, body)
            try:
                if email_ssl:
                    server = smtplib.SMTP(email_hostname, email_port)
                    server.ehlo()
                    server.starttls()
                else:
                    server = smtplib.SMTP_SSL(email_hostname, email_port)
                    server.ehlo()
                server.login(email_username, email_password)
                server.sendmail(email_from, email_to, message)
                server.close()

            except:
                logger.warning('Failed to send email.')
        else:
            logger.debug('event %s [%d] NOT in %s', row[4], row[0], alerts)
    if commit:
        db_conn.commit()

def identify_macs():
    import re
    import httplib
    db_cursor.execute('SELECT s.mac FROM seen s LEFT JOIN info i ON s.mac = i.mac WHERE s.active = 1 AND i.mac IS NULL')
    rows = db_cursor.fetchall()
    commit = 0
    for row in rows:
        commit = 1
        raw_mac = row[0]
        if re.match("[0-9a-f]{2}([-:])[0-9a-f]{2}(\\1[0-9a-f]{2}){4}$", raw_mac.lower()):
            mac = raw_mac
        else:
            # @TODO support - instead of : in mac
            mac = []
            pieces = raw_mac.split(':')
            for piece in pieces:
                if len(piece) == 1:
                    piece = '0'+piece
                mac.append(piece)
            mac = ":".join(mac)
        logger.debug('Looking up vendor for [%s]', raw_mac)
        http = httplib.HTTPConnection('api.macvendors.com', 80)
        url = """/%s""" % mac
        http.request("GET", url)
        response = http.getresponse()
        if response.status == 200 and response.reason == 'OK':
            vendor = response.read()
            logger.info('Identified [%s] as %s', raw_mac, vendor)
            db_cursor.execute('INSERT INTO info (mac, vendor) VALUES (?, ?)', (raw_mac, vendor))
        else:
            logger.info('Failed identify vendor for [%s]', raw_mac)
            db_cursor.execute("INSERT INTO info (mac, vendor) VALUES (?, 'unknown')", (raw_mac,))

def send_email_digests():
    print 'digests'

if __name__ == '__main__':
    if os.getuid() != 0:
        logger.critical("netgrasp must be run as root, exiting")
        sys.exit('ERROR: Netgrasp must be run as root.')

    try:
        import sqlite3
    except:
        logger.critical("failed to import sqlite3, try: 'pip install sqlite3', exiting")
        sys.exit("ERROR: Failed to import sqlite3, try: 'pip install sqlite3'")

    default_uid = 1 # typically daemon user
    default_gid = 1 # typically daemon group
    default_loglevel = logging.WARN

    multiprocessing.log_to_stderr()
    logger = multiprocessing.get_logger()

    config = ConfigParser.ConfigParser()
    found = config.read(['/etc/netgrasp.cfg', '/usr/local/etc/netgrasp.cfg', '~/.netgrasp.cfg', './netgrasp.cnf'])

    if config.has_section('Logging'):
        if config.has_option('Logging', 'level'):
            loglevel = config.get('Logging', 'level')
            logger.setLevel(loglevel)
            logger.debug('Logging: setting loglevel to %s', loglevel)
        else:
            logger.setLevel(default_loglevel)
    else:
        logger.setLevel(default_loglevel)

    logger.debug('configuration files: %s', found)

    if config.has_section('Security'):
        if config.has_option('Security', 'gid'):
            gid = config.getint('Security', 'gid');
        else:
            gid = default_gid
        if config.has_option('Security', 'uid'):
            uid = config.getint('Security', 'uid');
        else:
            uid = default_gid
    else:
        # Default to uid/gid 1, typically the daemon user
        gid = default_gid;
        uid = default_uid;
    logger.debug('Security: setting uid to %d, gid to %d', uid, gid)

    if config.has_section('Database'):
        if config.has_option('Database', 'filename'):
            db_filename = config.get('Database', 'filename');
        else:
            logger.critical("No database defined in configuration file, exiting.")
            sys.exit("No database filename defined in configuration file, exiting.")
    else:
        logger.critical("No database defined in configuration file, exiting.")
        sys.exit("No database filename defined in configuration file, exiting.")

    parent_conn, child_conn = multiprocessing.Pipe()
    wiretap = multiprocessing.Process(name='wiretap', target=wiretap, args=[child_conn])
    wiretap.daemon = True
    wiretap.start()

    # drop all root privileges, we no longer need them
    os.setgroups([])
    os.setgid(gid)
    os.setuid(uid)

    assert (os.getuid() != 0) and (os.getgid() != 0), 'Failed to drop root privileges, aborting.'
    logger.info('main process running as user %s',  whoami())

    signal.signal(signal.SIGINT, clean_shutdown)

    try:
        db_conn = sqlite3.connect(db_filename, detect_types=sqlite3.PARSE_DECLTYPES)
    except:
        logger.critical("failed to open or create %s (as user %s), exiting", db_filename, whoami())
        parent_conn.send('ABORT')
        sys.exit("ERROR: Failed to open or create database file.")
    logger.info('opened %s as user %s', db_filename, whoami());
    # create database if necessary
    db_cursor = db_conn.cursor()
    create_database()

    arplog = False
    if config.has_section('Logging') and config.has_option('Logging', 'arplog'):
        if config.getboolean('Logging', 'arplog') == True:
            arplog = True
    if arplog:
        logger.debug('Logging: arplog enabled')
    else:
        logger.debug('Logging: arplog disabled')

    if config.has_section('Listen') and config.has_option('Listen', 'active_timeout'):
        active_timeout = config.getint('Listen', 'active_timeout')
        logger.debug('Listen: setting active_timeout to %d', active_timeout)
    else:
        active_timeout = 60 * 20 # default to 20 minutes
        logger.debug('Listen: defaulting active_timeout to %d', active_timeout)

    if config.has_section('Email'):
        if config.has_option('Email', 'to'):
            # @TODO: Cleanup spaces after commas
            email_to = config.get('Email', 'to').split(',')
            valid = True
            for email in email_to:
                # Very simplistic email address validation.
                if not '@' in parseaddr(email)[1]:
                    valid = False
                    logger.warn('Email: invalid email to address (%s), email disabled', email)
            if not valid:
                email_to = False

        if config.has_option('Email', 'from'):
            email_from = config.get('Email', 'from')
            # Very simplistic email address validation.
            if not '@' in parseaddr(email_from)[1]:
                logger.info('Email: invalid email from address (%s), emails disabled', email_from)
                email_from = False
        if config.has_option('Email', 'smtp_hostname'):
            email_hostname = config.get('Email', 'smtp_hostname')
        if config.has_option('Email', 'smtp_port'):
            email_port = config.getint('Email', 'smtp_port')
        if config.has_option('Email', 'smtp_ssl'):
            email_ssl = config.getboolean('Email', 'smtp_ssl')
        else:
            email_ssl = False
        if config.has_option('Email', 'smtp_username'):
            email_username = config.get('Email', 'smtp_username')
        if config.has_option('Email', 'smtp_password'):
            email_password = config.get('Email', 'smtp_password')
        # @TODO validate coonfigured alerts and digests
        if config.has_option('Email', 'alerts'):
            alerts = config.get('Email', 'alerts').split(',')
        if config.has_option('Email', 'digests'):
            digests = config.get('Email', 'digests').split(',')

    if email_to and email_from and email_hostname and email_port and email_username and email_password:
        if alerts:
            logger.info('Sending alerts %s to %s from %s', alerts, email_to, email_from)
        if digests:
            logger.info('Sending digests %s to %s from %s', digests, email_to, email_from)
    else:
        logger.warning('Email is not properly configured, no notifications will be sent.')

    import dpkt

    # loop forever, listening for ARP packets ...
    while True:
      identify_macs()
      detect_stale_ips()
      send_email_alerts()
      packet = parent_conn.recv()
      src_ip = socket.inet_ntoa(packet.data.spa)
      src_mac = "%x:%x:%x:%x:%x:%x" % struct.unpack("BBBBBB", packet.src)
      dst_ip = socket.inet_ntoa(packet.data.tpa)
      dst_mac = "%x:%x:%x:%x:%x:%x" % struct.unpack("BBBBBB", packet.dst)
      if (packet.data.op == dpkt.arp.ARP_OP_REQUEST):
          logger.debug('ARP request from %s (%s) to %s (%s)', src_ip, src_mac, dst_ip, dst_mac)
          ip_seen(src_ip, src_mac, dst_ip, dst_mac)
          ip_request(dst_ip, dst_mac)
      elif (packet.data.op == dpkt.arp.ARP_OP_REPLY):
          ip_seen(src_ip, src_mac, dst_ip, dst_mac)
          logger.debug('ARP reply from %s (%s) to %s (%s)', src_ip, src_mac, dst_ip, dst_mac)

### @TODO
###
### # MAC lookups:
###     https://regauth.standards.ieee.org/standards-ra-web/pub/view.html#registries
###     https://macvendors.com
###
### # Validate IP addresses:
###     https://en.wikipedia.org/wiki/Reserved_IP_addresses
###
### # Report on anomolies
###      - MAC showing up multiple times
###      - destination/source IP of 0.0.0.0
###
### # Support listening on multiple interfaces
###
### # Add cross-platform UI for monitoring network, configuring, and alerting
###      - https://kivy.org
###      - https://wiki.python.org/moin/GuiProgramming

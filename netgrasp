#!/usr/bin/env python
import os
import sys
import signal
import multiprocessing
import ConfigParser
import io
import logging
import pwd
import struct
import socket
import datetime
from email.utils import parseaddr

BROADCAST = 'ff:ff:ff:ff:ff:ff'

EVENT_REQUESTED_FIRST   = 'first_requested'
EVENT_REQUESTED         = 'requested'
EVENT_SEEN_FIRST        = 'first_seen'
EVENT_SEEN_FIRST_RECENT = 'first_seen_recently'
EVENT_SEEN              = 'seen'
EVENT_STALE             = 'stale'

PROCESSED_ALERT         = 1
PROCESSED_DAILY_DIGEST  = 2
PROCESSED_WEEKLY_DIGEST = 4

def wiretap(child_conn):
    import sys
    name = multiprocessing.current_process().name
    assert os.getuid() == 0, 'Unable to initiate pcap, must be run as root.'
    logger.info('wiretap process running as user %s',  whoami())
    try:
        import dpkt
    except:
        logger.critical("failed to import dpkt, try: 'pip install dpkt', exiting")
        sys.exit("ERROR: Failed to import dpkt, try: 'pip install dpkt'")
    try:
        import pcap
    except:
        logger.critical("failed to import pcap, try: 'pip install pypcap', exiting")
        sys.exit("ERROR: Failed to import pcap, try: 'pip install pypcap'")

    devices = pcap.findalldevs()
    logger.debug('identified devices: %s', devices)
    if len(devices) <= 0:
      logger.critical('no available devices (are you in a jail?), exiting')
      sys.exit("ERROR: No available devices, try running tcpdump manually to debug.")
    default_interface = devices[0]

    if config.has_section('Listen'):
      if config.has_option('Listen', 'interface'):
        default_interface = config.get('Listen', 'interface');
        if default_interface not in devices:
          logger.critical('invalid interface %s configured, exiting.', default_interface)
          sys.exit("ERROR: Invalid interface configured.")
        logger.debug('Listen: setting interface to %s', default_interface)
      else:
        logger.info('no interface configured, attempt to use first available.')
    else:
      logger.info('no interface configured, attempt to use first available.')

    interface = default_interface
    logger.info('configured to listen on interface %s', interface)
    local_net, local_mask = pcap.lookupnet(interface)

    pc = pcap.pcap(name=interface, snaplen=256, promisc=True, timeout_ms = 100, immediate=True)

    # drop all root privileges, we no longer need them
    os.setgroups([])
    os.setgid(gid)
    os.setuid(uid)

    assert (os.getuid() != 0) and (os.getgid() != 0), 'Failed to drop root privileges, aborting.'
    logger.info('wiretap process running as user %s',  whoami())

    pc.setfilter('arp')

    while True:
        if child_conn.poll():
            message = child_conn.recv()
            if (message == 'ABORT'):
                logger.critical('we have received ABORT message, exiting')
                sys.exit(0)
        pc.loop(1, received_arp, child_conn)

def received_arp(hdr, data, child_conn):
    import dpkt
    logger.debug('arp packet sniffed')
    child_conn.send(dpkt.ethernet.Ethernet(data))
    exit

def whoami():
    whoami = pwd.getpwuid(os.getuid())
    return whoami[0]

def set_state(key, value):
    logger.debug('Set key[%s] to value[%s]', key, value)
    db_cursor.execute('INSERT OR REPLACE INTO state (key, value) VALUES (?, ?)', (key, value));

def get_state(key, default_value):
    db_cursor.execute('SELECT value FROM state WHERE key=?', (key,));
    value = db_cursor.fetchone();
    if value:
        return value[0]
    else:
        return default_value

def pretty_date(time):
    if not time:
        return False
    now = datetime.datetime.now()
    diff = now - time
    second_diff = diff.seconds
    day_diff = diff.days

    if day_diff < 0:
        return ''

    if day_diff == 0:
        if second_diff < 10:
            return "just now"
        if second_diff < 60:
            return str(second_diff) + " seconds ago"
        if second_diff < 120:
            return "a minute ago"
        if second_diff < 3600:
            return str(second_diff / 60) + " minutes ago"
        if second_diff < 7200:
            return "an hour ago"
        if second_diff < 86400:
            return str(second_diff / 3600) + " hours ago"
    if day_diff == 1:
        return "Yesterday"
    if day_diff < 7:
        return str(day_diff) + " days ago"
    if day_diff < 31:
        return str(day_diff / 7) + " weeks ago"
    if day_diff < 365:
        return str(day_diff / 30) + " months ago"
    return str(day_diff / 365) + " years ago"

def create_database():
    db_cursor.execute("""
      CREATE TABLE IF NOT EXISTS state(
        id INTEGER PRIMARY KEY,
        key VARCHAR UNIQUE,
        value TEXT
      )
    """)
    db_cursor.execute("""
      CREATE TABLE IF NOT EXISTS seen(
        sid INTEGER PRIMARY KEY,
        mac TEXT,
        ip TEXT,
        interface TEXT,
        network TEXT,
        firstSeen TIMESTAMP,
        firstRequested TIMESTAMP,
        lastSeen TIMESTAMP,
        lastRequested TIMESTAMP,
        counter NUMERIC,
        active NUMERIC,
        self NUMERIC
      )
    """)
    db_cursor.execute("""
      CREATE TABLE IF NOT EXISTS arplog(
        aid INTEGER PRIMARY KEY,
        src_mac TEXT,
        src_ip TEXT,
        dst_mac TEXT,
        dst_ip TEXT,
        request NUMERIC,
        interface TEXT,
        network TEXT,
        timestamp TIMESTAMP
      )
    """)
    db_cursor.execute("""
      CREATE TABLE IF NOT EXISTS event(
        eid INTEGER PRIMARY KEY,
        mac TEXT,
        ip TEXT,
        interface TEXT,
        network TEXT,
        timestamp TIMESTAMP,
        processed NUMERIC,
        event TEXT
      )
    """)
    db_cursor.execute("""
      CREATE TABLE IF NOT EXISTS vendor(
        vid INTEGER PRIMARY KEY,
        mac TEXT,
        vendor TEXT,
        customname TEXT
      )
    """)
    db_cursor.execute("""
      CREATE TABLE IF NOT EXISTS host(
        hid INTEGER PRIMARY KEY,
        mac TEXT,
        ip TEXT,
        hostname TEXT,
        customname TEXT
      )
    """)
    db_conn.commit()

def clean_shutdown(signal, frame):
    # Log the reason we have exited
    logger.critical("SIGINT received, exiting")
    sys.exit(0)

def ip_is_mine(ip):
    return (ip == socket.gethostbyname(socket.gethostname()))

def first_seen(ip, mac):
    logger.debug("SELECT firstSeen FROM seen WHERE ip = '%s' AND mac = '%s' ORDER BY firstSeen ASC LIMIT 1", ip, mac)
    db_cursor.execute('SELECT firstSeen FROM seen WHERE ip=? AND mac=? ORDER BY firstSeen ASC LIMIT 1', (ip, mac))
    active = db_cursor.fetchone()
    if active:
        return active[0]
    else:
        return False

def first_requested(ip, mac):
    logger.debug("SELECT firstRequested FROM seen WHERE ip = '%s' AND mac = '%s' ORDER BY firstRequested ASC LIMIT 1", ip, mac)
    db_cursor.execute('SELECT firstRequested FROM seen WHERE ip=? AND mac=? ORDER BY firstRequested ASC LIMIT 1', (ip, mac))
    active = db_cursor.fetchone()
    if active:
        return active[0]
    else:
        return False

def ip_seen(src_ip, src_mac, dst_ip, dst_mac, request):
    now = datetime.datetime.now()

    if arplog:
      logger.debug("INSERT INTO arplog (src_mac, src_ip, dst_mac, dst_ip, request, timestamp) VALUES('%s', '%s', '%s', '%s', '%d', '%s')", src_mac, src_ip, dst_mac, dst_ip, request, now)
      db_cursor.execute('INSERT INTO arplog (src_mac, src_ip, dst_mac, dst_ip, request, timestamp) VALUES(?, ?, ?, ?, ?, ?)', (src_mac, src_ip, dst_mac, dst_ip, request, now))

    # @TODO research and see if we should be treating this another way
    if (src_ip == '0.0.0.0'):
        logger.info('Ignoring IP source of 0.0.0.0');
        return False

    lastSeen = False
    lastRequested = False
    counter = 0
    logger.debug("SELECT lastSeen, lastRequested, counter FROM seen WHERE ip = '%s' AND mac = '%s' AND active=1", src_ip, src_mac)
    db_cursor.execute('SELECT lastSeen, lastRequested, counter FROM seen WHERE ip=? AND mac=? AND active=1', (src_ip, src_mac))
    active = db_cursor.fetchone()
    if active:
        lastSeen = active[0]
        lastRequested = active[1]
        counter = active[2]
    else:
        if (src_mac != BROADCAST):
            logger.debug("SELECT lastSeen, lastRequested, counter FROM seen WHERE ip = '%s' AND mac = '%s' AND active=1", src_ip, BROADCAST)
            db_cursor.execute('SELECT lastSeen, lastRequested, counter FROM seen WHERE ip=? AND mac=? AND active=1', (src_ip, BROADCAST))
            active = db_cursor.fetchone()
            if active:
                lastSeen = active[0]
                lastRequested = active[1]
                counter = active[2]

    log_event(src_ip, src_mac, EVENT_SEEN)
    if lastSeen or lastRequested:
        if lastSeen:
            # has been active recently
            logger.debug('%s (%s) is active', src_ip, src_mac)
            logger.debug("UPDATE seen set mac='%s', lastSeen='%s', counter=?, active=1 WHERE ip='%s'", src_mac, now, src_ip)
            db_cursor.execute('UPDATE seen set mac=?, lastSeen=?, counter=?, active=1 WHERE ip=?', (src_mac, now, counter + 1, src_ip))
        else:
            # has not been active recently, but was requested recently
            if first_seen(src_ip, src_mac):
                # First time we've seen IP since it was stale.
                log_event(src_ip, src_mac, EVENT_SEEN_FIRST_RECENT)
                timeSince = datetime.datetime.now() - lastSeen
                logger.info('%s (%s) is active again (after %s)', src_ip, src_mac, timeSince)
            else:
                # First time we've actively seen this IP.
                log_event(src_ip, src_mac, EVENT_SEEN_FIRST)
                logger.info('%s (%s) is active', src_ip, src_mac)

            # @TODO properly handle multiple active occurences of the same IP
            logger.debug("UPDATE seen set mac='%s', firstSeen='%s', lastSeen='%s', counter=%d, active=1, WHERE ip='%s'", src_mac, now, now, counter + 1, src_ip)
            db_cursor.execute('UPDATE seen set mac=?, firstSeen=?, lastSeen=?, counter=?, active=1 WHERE ip=?', (src_mac, now, now, counter + 1, src_ip))
        db_conn.commit()
    else:
        # First time we've seen this IP.
        log_event(src_ip, src_mac, EVENT_SEEN_FIRST)
        logger.debug("INSERT INTO seen (mac, ip, firstSeen, lastSeen, counter, active, self) VALUES('%s', '%s', '%s', '%s', 1, 1, %d)", src_mac, src_ip, now, now, ip_is_mine(src_ip))
        db_cursor.execute('INSERT INTO seen (mac, ip, firstSeen, lastSeen, counter, active, self) VALUES(?, ?, ?, ?, 1, 1, ?)', (src_mac, src_ip, now, now, ip_is_mine(src_ip)))
        logger.info('%s (%s) is active, first time seeing', src_ip, src_mac)
        db_conn.commit()

def ip_request(ip, mac):
    now = datetime.datetime.now()

    lastRequested = False
    logger.debug("SELECT lastRequested FROM seen WHERE ip = '%s' AND mac = '%s' AND active=1", ip, mac)
    db_cursor.execute('SELECT lastRequested FROM seen WHERE ip=? AND mac=? AND active=1', (ip, mac))
    requested = db_cursor.fetchone()
    if requested:
        lastRequested = requested[0]
    else:
        if (mac == BROADCAST):
            # Maybe we already have seen a request for this address
            logger.debug("SELECT lastRequested FROM seen WHERE ip = '%s' AND mac = '%s' AND active=1", ip, BROADCAST)
            db_cursor.execute('SELECT lastRequested FROM seen WHERE ip=? AND mac=? AND active=1', (ip, BROADCAST))
            requested = db_cursor.fetchone()
            if requested:
                lastRequested = requested[0]

    log_event(ip, mac, EVENT_REQUESTED)
    if lastRequested:
        # Update:
        logger.debug("UPDATE seen set lastRequested='%s' WHERE ip='%s' AND mac='%s'", now, ip, mac)
        db_cursor.execute('UPDATE seen set lastRequested=? WHERE ip=? AND mac=?', (now, ip, mac))
        logger.debug('%s (%s) requested', ip, mac)
        db_conn.commit()
    else:
        # First time we've seen a request for this IP.
        log_event(ip, mac, EVENT_REQUESTED_FIRST)
        logger.debug("INSERT INTO seen (mac, ip, firstRequested, lastRequested, counter, active, self) VALUES('%s', '%s', '%s', '%s', 0, 1, %d)", mac, ip, now, now, ip_is_mine(ip))
        db_cursor.execute("INSERT INTO seen (mac, ip, firstRequested, lastRequested, counter, active, self) VALUES(?, ?, ?, ?, 1, 1, ?)", (mac, ip, now, now, ip_is_mine(ip)))
        logger.info('%s (%s) requested, first time seeing', ip, mac)
        db_conn.commit()

def log_event(ip, mac, event):
    now = datetime.datetime.now()
    logger.debug("INSERT INTO event (mac, ip, timestamp, processed, event) VALUES('%s', '%s', '%s', '%s', '%s')", mac, ip, now, 0, event)
    db_cursor.execute('INSERT INTO event (mac, ip, timestamp, processed, event) VALUES(?, ?, ?, ?, ?)', (mac, ip, now, 0, event))

# Mark IP/MAC pairs as no longer active if we've not seen ARP activity for >active_timeout seconds
def detect_stale_ips():
    stale = datetime.datetime.now() - datetime.timedelta(seconds=active_timeout)
    logger.debug("SELECT mac, ip, firstSeen, lastSeen FROM seen WHERE active = 1 AND lastSeen < '%s'", stale)
    db_cursor.execute('SELECT mac, ip, firstSeen, lastSeen FROM seen WHERE active = 1 AND lastSeen < ?', (stale,))
    rows = db_cursor.fetchall()
    commit = 0
    for row in rows:
        if (row[2] and row[3]):
            timeActive = row[3] - row[2]
        else:
            timeActive = 'unknown'
        log_event(row[1], row[0], EVENT_STALE)
        logger.info("%s [%s] is no longer active (was active for %s)", row[1], row[0], timeActive)
        logger.debug("UPDATE seen SET active = 0 WHERE mac = '%s' AND ip = '%s'", row[0], row[1])
        db_cursor.execute('UPDATE seen SET active = 0 WHERE mac=? AND ip=?', (row[0], row[1]))
        commit = 1
    if commit:
        db_conn.commit()

def send_email_alerts():
    import smtplib
    day = datetime.datetime.now() - datetime.timedelta(days=1)
    logger.debug('SELECT eid, mac, ip, timestamp, event FROM event WHERE NOT (processed & %d)', PROCESSED_ALERT);
    # @TODO, use variable: 1 == PROCESSED_ALERT
    db_cursor.execute('SELECT eid, mac, ip, timestamp, event, processed FROM event WHERE NOT (processed & 1)');
    rows = db_cursor.fetchall()
    commit = 0
    for row in rows:
        commit = 1
        logger.debug('processing event %d for %s [%s] at %s', row[0], row[2], row[1], row[3])
        db_cursor.execute('UPDATE event SET processed = ? WHERE eid = ?', (row[5] + 1, row[0]))
        # only send emails for configured events
        if row[4] in alerts:
            logger.info('event %s [%d] in %s, generating notification email', row[4], row[0], alerts)
            # get more information about this entry ...
            db_cursor.execute('SELECT s.firstSeen, s.firstRequested, s.lastSeen, s.lastRequested, s.active, s.self, v.vendor, v.customname, h.hostname, h.customname FROM seen s LEFT JOIN vendor v ON s.mac = v.mac LEFT JOIN host h ON s.mac = h.mac AND s.ip = h.ip WHERE s.mac=? AND s.ip=?', (row[1], row[2]))
            info = db_cursor.fetchone()
            firstSeen = first_seen(row[2], row[1])
            firstRequested = first_requested(row[2], row[1])
            subject = """Netgrasp alert: %s""" % (row[4])
            body = """IP %s [%s]\n  Vendor: %s\nCustom name: %s\n  Hostname: %s\n  Custom host name: %s\n  First seen: %s\n  First seen recently: %s\n  Last seen: %s\n  First requested: %s\n  Last requested: %s\n  Currently active: %d\n  Self: %d\n""" % (row[2], row[1], info[6], info[7], info[8], info[9], pretty_date(firstSeen), pretty_date(info[0]), pretty_date(info[2]), pretty_date(info[3]), pretty_date(firstRequested), info[4], info[5])
            db_cursor.execute('SELECT DISTINCT dst_ip, dst_mac FROM arplog WHERE src_mac=? AND timestamp>=?', (row[1], day))
            results = db_cursor.fetchall()
            if results:
                body += """\nIn the last day, this device talked to:"""
            for peer in results:
                body += """\n - %s (%s)""" % (peer[0], name_ip(row[1], row[2]))
            message = """From: %s\nTo: %s\nSubject: %s\n\n%s""" % (email_from, ", ".join(email_to), subject, body)
            try:
                if email_ssl:
                    server = smtplib.SMTP(email_hostname, email_port)
                    server.ehlo()
                    server.starttls()
                else:
                    server = smtplib.SMTP_SSL(email_hostname, email_port)
                    server.ehlo()
                server.login(email_username, email_password)
                server.sendmail(email_from, email_to, message)
                server.close()

            except:
                logger.warning('Failed to send email.')
        else:
            logger.debug('event %s [%d] NOT in %s', row[4], row[0], alerts)
    if commit:
        db_conn.commit()

def identify_macs():
    import re
    import httplib
    commit = 0

    db_cursor.execute('SELECT s.mac, s.ip FROM seen s LEFT JOIN vendor v ON s.mac = v.mac WHERE s.active = 1 AND v.mac IS NULL')
    rows = db_cursor.fetchall()
    for row in rows:
        commit = 1
        raw_mac = row[0]
        if re.match("[0-9a-f]{2}([-:])[0-9a-f]{2}(\\1[0-9a-f]{2}){4}$", raw_mac.lower()):
            mac = raw_mac
        else:
            mac = []
            pieces = raw_mac.split(':')
            if not pieces:
                pieces = row_mac.split('-')
            for piece in pieces:
                if len(piece) == 1:
                    piece = '0'+piece
                mac.append(piece)
            mac = ":".join(mac)
        logger.debug('Looking up vendor for %s [%s]', row[1], raw_mac)
        http = httplib.HTTPConnection('api.macvendors.com', 80)
        url = """/%s""" % mac
        http.request("GET", url)
        response = http.getresponse()
        if response.status == 200 and response.reason == 'OK':
            vendor = response.read()
            logger.info('Identified %s [%s] as %s', row[1], raw_mac, vendor)
            db_cursor.execute('INSERT INTO vendor (mac, vendor) VALUES (?, ?)', (raw_mac, vendor))
        else:
            logger.info('Failed identify vendor for [%s]', raw_mac)
            db_cursor.execute("INSERT INTO vendor (mac, vendor) VALUES (?, 'unknown')", (raw_mac,))

    db_cursor.execute('SELECT s.mac, s.ip FROM seen s LEFT JOIN host h ON s.mac = h.mac AND s.ip = h.ip WHERE s.active = 1 AND h.mac IS NULL')
    rows = db_cursor.fetchall()
    for row in rows:
        commit = 1
        logger.debug('requesting gethostbyaddr for %s [%s]', row[1], row[0])
        try:
            hostname = socket.gethostbyaddr(row[1])
        except:
            hostname = ['unknown']
        logger.debug('hostname: %s', hostname)
        db_cursor.execute('INSERT INTO host (mac, ip, hostname) VALUES (?, ?, ?)', (row[0], row[1], hostname[0]))

    if commit:
        db_conn.commit()

def name_ip(mac, ip):
    logger.debug("SELECT h.mac, h.ip, h.customname, h.hostname, v.customname, v.vendor FROM host h LEFT JOIN vendor v ON h.mac = v.mac WHERE h.ip='%s' AND h.mac='%s'", ip,mac)
    db_cursor.execute("SELECT h.mac, h.ip, h.customname, h.hostname, v.customname, v.vendor FROM host h LEFT JOIN vendor v ON h.mac = v.mac WHERE h.ip=? AND h.mac=?", (ip,mac))
    detail = db_cursor.fetchone()
    if not detail:
        return detail
    if detail[2]:
        return detail[2]
    elif detail[3] and (detail[3] != 'unknown'):
        return detail[3]
    elif detail[4]:
        return detail[4]
    elif detail[5]:
        return """Unidentified device by %s""" % (detail[5])
    else:
        return detail[0]

def send_email_digests():
    import smtplib
    if 'daily' in digests:
        now = datetime.datetime.now()
        day = now - datetime.timedelta(days=1)
        db_cursor.execute("SELECT DISTINCT mac, ip FROM event WHERE NOT (processed & 2) AND timestamp>=? AND timestamp<=? AND event = 'requested'", (day, now))
        requested = db_cursor.fetchall()
        db_cursor.execute("SELECT DISTINCT mac, ip FROM event WHERE NOT (processed & 2) AND timestamp>=? AND timestamp<=? AND event = 'seen'", (day, now))
        seen = db_cursor.fetchall()

        subject = "Netgrasp daily digest"
        body = """In the past 24 hours, %d IPs were active:""" % (len(seen))
        noisy = []
        for ip in seen:
            db_cursor.execute('SELECT COUNT(DISTINCT(dst_ip)) FROM arplog WHERE request=1 AND src_ip=? AND timestamp>=? AND timestamp <=?', (ip[1], day, now))
            requests = db_cursor.fetchone()
            if (requests[0] > 10):
                noisy.append((ip[0], ip[1], requests[0], name_ip(ip[0], ip[1])))
            body += """\n - %s (%s)""" % (ip[1], name_ip(ip[0], ip[1]))

        body += """\n\n%d unique IPs requested.""" % (len(requested),)

        if noisy:
            body += """\n\nThe following devices requested 10 or more IPs on the network:"""
            for noise in noisy:
                body += """\n - %s (%s) requested %d IP addresses""" % (noise[1], name_ip(noise[0], noise[1]), noise[2])
                if (noise[2] > 50):
                    body += " (network scan?)"

        db_cursor.execute('SELECT eid, processed FROM event WHERE timestamp>=? AND timestamp<=?', (day, now))
        rows = db_cursor.fetchall()
        for row in rows:
            db_cursor.execute('UPDATE event SET processed=? WHERE eid=?', (row[1] + 2, row[0]))

        message = """From: %s\nTo: %s\nSubject: %s\n\n%s""" % (email_from, ", ".join(email_to), subject, body)
        try:
            if email_ssl:
                server = smtplib.SMTP(email_hostname, email_port)
                server.ehlo()
                server.starttls()
            else:
                server = smtplib.SMTP_SSL(email_hostname, email_port)
                server.ehlo()
            server.login(email_username, email_password)
            server.sendmail(email_from, email_to, message)
            server.close()

        except:
            logger.warning('Failed to send email.')

    if 'weekly' in alerts:
        week = datetime.datetime.now() - datetime.timedelta(weeks=1)
        db_cursor.execute('SELECT eid, mac, ip, timestamp, event, processed FROM event WHERE NOT (processed & 4) AND timestamp>=?', (week,));

if __name__ == '__main__':
    if os.getuid() != 0:
        logger.critical("netgrasp must be run as root, exiting")
        sys.exit('ERROR: Netgrasp must be run as root.')

    try:
        import sqlite3
    except:
        logger.critical("failed to import sqlite3, try: 'pip install sqlite3', exiting")
        sys.exit("ERROR: Failed to import sqlite3, try: 'pip install sqlite3'")

    default_uid = 1 # typically daemon user
    default_gid = 1 # typically daemon group
    default_loglevel = logging.WARN

    multiprocessing.log_to_stderr()
    logger = multiprocessing.get_logger()

    config = ConfigParser.ConfigParser()
    found = config.read(['/etc/netgrasp.cfg', '/usr/local/etc/netgrasp.cfg', '~/.netgrasp.cfg', './netgrasp.cnf'])

    if config.has_section('Logging'):
        if config.has_option('Logging', 'level'):
            loglevel = config.get('Logging', 'level')
            logger.setLevel(loglevel)
            logger.debug('Logging: setting loglevel to %s', loglevel)
        else:
            logger.setLevel(default_loglevel)
    else:
        logger.setLevel(default_loglevel)

    logger.debug('configuration files: %s', found)

    if config.has_section('Security'):
        if config.has_option('Security', 'gid'):
            gid = config.getint('Security', 'gid');
        else:
            gid = default_gid
        if config.has_option('Security', 'uid'):
            uid = config.getint('Security', 'uid');
        else:
            uid = default_gid
    else:
        # Default to uid/gid 1, typically the daemon user
        gid = default_gid;
        uid = default_uid;
    logger.debug('Security: setting uid to %d, gid to %d', uid, gid)

    if config.has_section('Database'):
        if config.has_option('Database', 'filename'):
            db_filename = config.get('Database', 'filename');
        else:
            logger.critical("No database defined in configuration file, exiting.")
            sys.exit("No database filename defined in configuration file, exiting.")
    else:
        logger.critical("No database defined in configuration file, exiting.")
        sys.exit("No database filename defined in configuration file, exiting.")

    parent_conn, child_conn = multiprocessing.Pipe()
    wiretap = multiprocessing.Process(name='wiretap', target=wiretap, args=[child_conn])
    wiretap.daemon = True
    wiretap.start()

    # drop all root privileges, we no longer need them
    os.setgroups([])
    os.setgid(gid)
    os.setuid(uid)

    assert (os.getuid() != 0) and (os.getgid() != 0), 'Failed to drop root privileges, aborting.'
    logger.info('main process running as user %s',  whoami())

    signal.signal(signal.SIGINT, clean_shutdown)

    try:
        db_conn = sqlite3.connect(db_filename, detect_types=sqlite3.PARSE_DECLTYPES)
    except:
        logger.critical("failed to open or create %s (as user %s), exiting", db_filename, whoami())
        parent_conn.send('ABORT')
        sys.exit("ERROR: Failed to open or create database file.")
    logger.info('opened %s as user %s', db_filename, whoami());
    # create database if necessary
    db_cursor = db_conn.cursor()
    create_database()

    arplog = False
    if config.has_section('Logging') and config.has_option('Logging', 'arplog'):
        if config.getboolean('Logging', 'arplog') == True:
            arplog = True
    if arplog:
        logger.debug('Logging: arplog enabled')
    else:
        logger.debug('Logging: arplog disabled')

    if config.has_section('Listen') and config.has_option('Listen', 'active_timeout'):
        active_timeout = config.getint('Listen', 'active_timeout')
        logger.debug('Listen: setting active_timeout to %d', active_timeout)
    else:
        active_timeout = 60 * 20 # default to 20 minutes
        logger.debug('Listen: defaulting active_timeout to %d', active_timeout)

    if config.has_section('Email'):
        if config.has_option('Email', 'to'):
            # @TODO: Cleanup spaces after commas
            email_to = config.get('Email', 'to').split(',')
            valid = True
            for email in email_to:
                # Very simplistic email address validation.
                if not '@' in parseaddr(email)[1]:
                    valid = False
                    logger.warn('Email: invalid email to address (%s), email disabled', email)
            if not valid:
                email_to = False

        if config.has_option('Email', 'from'):
            email_from = config.get('Email', 'from')
            # Very simplistic email address validation.
            if not '@' in parseaddr(email_from)[1]:
                logger.info('Email: invalid email from address (%s), emails disabled', email_from)
                email_from = False
        if config.has_option('Email', 'smtp_hostname'):
            email_hostname = config.get('Email', 'smtp_hostname')
        if config.has_option('Email', 'smtp_port'):
            email_port = config.getint('Email', 'smtp_port')
        if config.has_option('Email', 'smtp_ssl'):
            email_ssl = config.getboolean('Email', 'smtp_ssl')
        else:
            email_ssl = False
        if config.has_option('Email', 'smtp_username'):
            email_username = config.get('Email', 'smtp_username')
        if config.has_option('Email', 'smtp_password'):
            email_password = config.get('Email', 'smtp_password')
        # @TODO validate coonfigured alerts and digests
        if config.has_option('Email', 'alerts'):
            alerts = config.get('Email', 'alerts').split(',')
        if config.has_option('Email', 'digests'):
            digests = config.get('Email', 'digests').split(',')

    if email_to and email_from and email_hostname and email_port and email_username and email_password:
        if alerts:
            logger.info('Sending alerts %s to %s from %s', alerts, email_to, email_from)
        if digests:
            logger.info('Sending digests %s to %s from %s', digests, email_to, email_from)
    else:
        logger.warning('Email is not properly configured, no notifications will be sent.')

    import dpkt

    # loop forever, listening for ARP packets ...
    while True:
        identify_macs()
        detect_stale_ips()
        send_email_alerts()
        daily_digest_timestamp = get_state('daily_digest_timestamp', '')
        if daily_digest_timestamp:
            daily_digest_timestamp = datetime.datetime.strptime(daily_digest_timestamp, "%Y-%m-%d %H:%M:%S.%f")
        else:
            daily_digest_timestamp = datetime.datetime.now() + datetime.timedelta(days=1)
            set_state('daily_digest_timestamp', daily_digest_timestamp)
        if datetime.datetime.now() >= daily_digest_timestamp:
            daily_digest_timestamp = datetime.datetime.now() + datetime.timedelta(days=1)
            set_state('daily_digest_timestamp', daily_digest_timestamp)
            send_email_digests()
        packet = parent_conn.recv()
        src_ip = socket.inet_ntoa(packet.data.spa)
        src_mac = "%x:%x:%x:%x:%x:%x" % struct.unpack("BBBBBB", packet.src)
        dst_ip = socket.inet_ntoa(packet.data.tpa)
        dst_mac = "%x:%x:%x:%x:%x:%x" % struct.unpack("BBBBBB", packet.dst)
        if (packet.data.op == dpkt.arp.ARP_OP_REQUEST):
            logger.debug('ARP request from %s (%s) to %s (%s)', src_ip, src_mac, dst_ip, dst_mac)
            ip_seen(src_ip, src_mac, dst_ip, dst_mac, True)
            ip_request(dst_ip, dst_mac)
        elif (packet.data.op == dpkt.arp.ARP_OP_REPLY):
            ip_seen(src_ip, src_mac, dst_ip, dst_mac, False)
            logger.debug('ARP reply from %s (%s) to %s (%s)', src_ip, src_mac, dst_ip, dst_mac)

### @TODO
###
### # Validate IP addresses:
###     https://en.wikipedia.org/wiki/Reserved_IP_addresses
###
### # Report on anomolies
###      - MAC showing up multiple times
###      - destination/source IP of 0.0.0.0
###
### # Support listening on multiple interfaces
###
### # Add cross-platform UI for monitoring network, configuring, and alerting
###      - https://kivy.org
###      - https://wiki.python.org/moin/GuiProgramming

#!/usr/bin/env python
import os
import sys
import signal
import multiprocessing
import ConfigParser
import io
import logging
import pwd
import struct
import socket
import sqlite3
import datetime

BROADCAST = 'ff:ff:ff:ff:ff:ff'

def wiretap(child_conn):
    import sys
    name = multiprocessing.current_process().name
    assert os.getuid() == 0, 'Unable to initiate pcap, must be run as root.'
    logger.info('wiretap process running as user %s',  whoami())
    try:
        import dpkt
    except:
        logger.critical("failed to import dpkt, try: 'pip install dpkt', exiting")
        sys.exit("ERROR: Failed to import dpkt, try: 'pip install dpkt'")
    try:
        import pcap
    except:
        logger.critical("failed to import pcap, try: 'pip install pypcap', exiting")
        sys.exit("ERROR: Failed to import pcap, try: 'pip install pypcap'")

    devices = pcap.findalldevs()
    logger.debug('identified devices: %s', devices)
    if len(devices) <= 0:
      logger.critical('no available devices (are you in a jail?), exiting')
      sys.exit("ERROR: No available devices, try running tcpdump manually to debug.")
    default_interface = devices[0]

    if config.has_section('Listen'):
      if config.has_option('Listen', 'interface'):
        default_interface = config.get('Listen', 'interface');
        if default_interface not in devices:
          logger.critical('invalid interface %s configured, exiting.', default_interface)
          sys.exit("ERROR: Invalid interface configured.")
        logger.debug('Listen: setting interface to %s', default_interface)
      else:
        logger.info('no interface configured, attempt to use first available.')
    else:
      logger.info('no interface configured, attempt to use first available.')

    interface = default_interface
    logger.info('configured to listen on interface %s', interface)
    local_net, local_mask = pcap.lookupnet(interface)

    pc = pcap.pcap(name=interface, snaplen=256, promisc=True, timeout_ms = 100, immediate=True)

    # drop all root privileges, we no longer need them
    os.setgroups([])
    os.setgid(gid)
    os.setuid(uid)

    assert (os.getuid() != 0) and (os.getgid() != 0), 'Failed to drop root privileges, aborting.'
    logger.info('wiretap process running as user %s',  whoami())

    pc.setfilter('arp')

    while True:
        if child_conn.poll():
            message = child_conn.recv()
            if (message == 'ABORT'):
                logger.critical('we have received ABORT message, exiting')
                sys.exit(0)
        pc.loop(1, received_arp, child_conn)

def received_arp(hdr, data, child_conn):
    import dpkt
    logger.debug('arp packet sniffed')
    child_conn.send(dpkt.ethernet.Ethernet(data))
    exit

def whoami():
    whoami = pwd.getpwuid(os.getuid())
    return whoami[0]

def create_database():
    # mac:             Hardware address, aka 'ff:ff:ff:ff:ff:ff'
    # ip:              IP address, aka '10.0.0.2013'
    # interface:       name of interface, aka 'en0'
    # network:         full address, aka '10.0.0.0/24'
    # firstSeen:       timestamp when IP first seen ever
    # firstSeenRecent: timestamp when IP first seen recently (during current active period)
    # lastSeen:        timestamp when IP last seen
    # lastRequested:   last time MAC was requested
    # active:          flag indicating whether mac is currently active
    # self:            flag indicating whether this is our mac/ip
    db_cursor.execute("""
      CREATE TABLE IF NOT EXISTS seen(
        mac TEXT,
        ip TEXT,
        interface TEXT,
        network TEXT,
        firstSeen TIMESTAMP,
        firstSeenRecent TIMESTAMP,
        lastSeen TIMESTAMP,
        lastRequested TIMESTAMP,
        active NUMERIC,
        self NUMERIC,
        PRIMARY KEY (mac, ip, network, interface)
      )
    """)
    db_conn.commit()

def clean_shutdown(signal, frame):
    # Log the reason we have exited
    logger.critical("SIGINT received, exiting")
    sys.exit(0)

def ip_is_mine(ip):
    return (ip == socket.gethostbyname(socket.gethostname()))

def ip_seen(ip, mac):
    now = datetime.datetime.now()
    exists = False

    logger.debug("SELECT active, lastSeen FROM seen WHERE ip = '%s' AND mac = '%s'", ip, mac)
    db_cursor.execute('SELECT active, lastSeen FROM seen WHERE ip=? AND mac=?', (ip, mac))
    rows = db_cursor.fetchall()
    if len(rows):
        exists = True
        active = rows[0][0]
        lastSeen = rows[0][1]
    else:
        if (mac != BROADCAST):
            logger.debug("SELECT active, lastSeen FROM seen WHERE ip = '%s' AND mac = '%s'", ip, BROADCAST)
            db_cursor.execute('SELECT active, lastSeen FROM seen WHERE ip=? AND mac=?', (ip, BROADCAST))
            rows = db_cursor.fetchall()
            if len(rows):
                exists = True
                active = rows[0][0]
                lastSeen = rows[0][1]

    if exists:
        # Update:
        if active or not lastSeen:
            logger.debug("UPDATE seen set mac='%s', lastSeen='%s', active=1 WHERE ip='%s'", mac, now, ip)
            db_cursor.execute('UPDATE seen set mac=?, lastSeen=?, active=? WHERE ip=?', (mac, now, 1, ip))
            if lastSeen:
                logger.debug('%s (%s) is active', ip, mac)
            else:
                logger.info('%s (%s) is active, first time seeing', ip, mac)
        else:
            timeSince = datetime.datetime.now() - lastSeen
            # First time we've seen IP since it was stale.
            logger.debug("UPDATE seen set mac='%s', firstSeenRecent='%s', lastSeen='%s', active=1 WHERE ip='%s'", mac, now, now, ip)
            db_cursor.execute('UPDATE seen set mac=?, firstSeenRecent=?, lastSeen=?, active=? WHERE ip=?', (mac, now, now, 1, ip))
            logger.info('%s (%s) is active again (after %s)', ip, mac, timeSince)
        db_conn.commit()
    else:
        # First time we've seen this IP.
        logger.debug("INSERT INTO seen (mac, ip, firstSeen, firstSeenRecent, lastSeen, active, self) VALUES('%s', '%s', '%s', '%s', '%s', %d, %d)", mac, ip, now, now, now, 1, ip_is_mine(ip))
        db_cursor.execute('INSERT INTO seen (mac, ip, firstSeen, firstSeenRecent, lastSeen, active, self) VALUES(?, ?, ?, ?, ?, ?, ?)', (mac, ip, now, now, now, 1, ip_is_mine(ip)))
        logger.info('%s (%s) is active, first time seeing', ip, mac)
        db_conn.commit()

def ip_request(ip, mac):
    now = datetime.datetime.now()
    exists = False

    logger.debug("SELECT active FROM seen WHERE ip = '%s' AND mac = '%s'", ip, mac)
    db_cursor.execute('SELECT active FROM seen WHERE ip=? AND mac=?', (ip, mac))
    rows = db_cursor.fetchall()
    if len(rows):
        exists = True
    else:
        if (mac == BROADCAST):
            # Maybe we already have this ARP address
            logger.debug("SELECT mac FROM seen WHERE ip = '%s'", ip)
            db_cursor.execute('SELECT mac FROM seen WHERE ip=?', (ip,))
            rows = db_cursor.fetchall()
            if len(rows):
              exists = True
              mac = rows[0][0]

    if exists:
        # Update:
        logger.debug("UPDATE seen set lastRequested='%s' WHERE ip='%s' AND mac='%s'", now, ip, mac)
        db_cursor.execute('UPDATE seen set lastRequested=? WHERE ip=? AND mac=?', (now, ip, mac))
        logger.debug('%s (%s) requested', ip, mac)
        db_conn.commit()
    else:
        # First time we've seen a request for this IP.
        logger.debug("INSERT INTO seen (mac, ip, lastRequested, active, self) VALUES('%s', '%s', '%s', 0, %d)", mac, ip, now, ip_is_mine(ip))
        db_cursor.execute("INSERT INTO seen (mac, ip, lastRequested, active, self) VALUES(?, ?, ?, 0, ?)", (mac, ip, now, ip_is_mine(ip)))
        logger.info('%s (%s) requested, first time seeing', ip, mac)
        db_conn.commit()

# Mark IP/MAC pairs as no longer active if we've not seen ARP activity for >active_timeout seconds
def detect_stale_ips():
    if config.has_section('Listen') and config.has_option('Listen', 'active_timeout'):
        active_timeout = config.getint('Listen', 'active_timeout')
        logger.debug('Listen: setting active_timeout to %d', active_timeout)
    else:
        active_timeout = 60 * 20 # default to 20 minutes
        logger.debug('Listen: defaulting active_timeout to %d', active_timeout)
    stale = datetime.datetime.now() - datetime.timedelta(seconds=active_timeout)
    logger.debug("SELECT mac, ip FROM seen WHERE active = 1 AND lastSeen < '%s'", stale)
    db_cursor.execute('SELECT mac, ip FROM seen WHERE active = 1 AND lastSeen < ?', (stale,))
    rows = db_cursor.fetchall()
    commit = 0
    for row in rows:
        logger.info("%s [%s] is no longer active", row[1], row[0])
        logger.debug("UPDATE seen SET active = 0 WHERE mac = '%s' AND ip = '%s'", row[0], row[1])
        db_cursor.execute('UPDATE seen SET active = 0 WHERE mac=? AND ip=?', (row[0], row[1]))
        commit = 1
    if commit:
        db_conn.commit()

if __name__ == '__main__':
    if os.getuid() != 0:
        logger.critical("netgrasp must be run as root, exiting")
        sys.exit('ERROR: Netgrasp must be run as root.')

    default_uid = 1 # typically daemon user
    default_gid = 1 # typically daemon group
    default_loglevel = logging.WARN

    multiprocessing.log_to_stderr()
    logger = multiprocessing.get_logger()

    config = ConfigParser.ConfigParser()
    found = config.read(['/etc/netgrasp.cfg', '/usr/local/etc/netgrasp.cfg', '~/.netgrasp.cfg', './netgrasp.cnf'])

    if config.has_section('Logging'):
        if config.has_option('Logging', 'level'):
            loglevel = config.get('Logging', 'level')
            logger.setLevel(loglevel)
            logger.debug('Logging: setting loglevel to %s', loglevel)
        else:
            logger.setLevel(default_loglevel)
    else:
        logger.setLevel(default_loglevel)

    logger.debug('configuration files: %s', found)

    if config.has_section('Security'):
        if config.has_option('Security', 'gid'):
            gid = config.getint('Security', 'gid');
        else:
            gid = default_gid
        if config.has_option('Security', 'uid'):
            uid = config.getint('Security', 'uid');
        else:
            uid = default_gid
    else:
        # Default to uid/gid 1, typically the daemon user
        gid = default_gid;
        uid = default_uid;
    logger.debug('Security: setting uid to %d, gid to %d', uid, gid)

    if config.has_section('Database'):
        if config.has_option('Database', 'filename'):
            db_filename = config.get('Database', 'filename');
        else:
            logger.critical("No database defined in configuration file, exiting.")
            sys.exit("No database filename defined in configuration file, exiting.")
    else:
        logger.critical("No database defined in configuration file, exiting.")
        sys.exit("No database filename defined in configuration file, exiting.")

    parent_conn, child_conn = multiprocessing.Pipe()
    wiretap = multiprocessing.Process(name='wiretap', target=wiretap, args=[child_conn])
    wiretap.daemon = True
    wiretap.start()

    # drop all root privileges, we no longer need them
    os.setgroups([])
    os.setgid(gid)
    os.setuid(uid)

    assert (os.getuid() != 0) and (os.getgid() != 0), 'Failed to drop root privileges, aborting.'
    logger.info('main process running as user %s',  whoami())

    signal.signal(signal.SIGINT, clean_shutdown)

    try:
        db_conn = sqlite3.connect(db_filename, detect_types=sqlite3.PARSE_DECLTYPES)
    except:
        logger.critical("failed to open or create %s (as user %s), exiting", db_filename, whoami())
        parent_conn.send('ABORT')
        sys.exit("ERROR: Failed to open or create database file.")
    logger.info('opened %s as user %s', db_filename, whoami());
    # create database if necessary
    db_cursor = db_conn.cursor()
    create_database()

    import dpkt

    # loop forever, listening for ARP packets ...
    while True:
      detect_stale_ips()
      packet = parent_conn.recv()
      src_ip = socket.inet_ntoa(packet.data.spa)
      src_mac = "%x:%x:%x:%x:%x:%x" % struct.unpack("BBBBBB", packet.src)
      dst_ip = socket.inet_ntoa(packet.data.tpa)
      dst_mac = "%x:%x:%x:%x:%x:%x" % struct.unpack("BBBBBB", packet.dst)
      if (packet.data.op == dpkt.arp.ARP_OP_REQUEST):
          logger.debug('ARP request from %s (%s) to %s (%s)', src_ip, src_mac, dst_ip, dst_mac)
          ip_seen(src_ip, src_mac)
          ip_request(dst_ip, dst_mac)
      elif (packet.data.op == dpkt.arp.ARP_OP_REPLY):
          ip_seen(src_ip, src_mac)
          ip_seen(dst_ip, dst_mac)
          logger.debug('ARP reply from %s (%s) to %s (%s)', src_ip, src_mac, dst_ip, dst_mac)
